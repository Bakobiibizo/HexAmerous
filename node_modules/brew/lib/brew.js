// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var brew, crypto, file, fs, iced, path, __iced_k, __iced_k_noop,
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  iced = {
    Deferrals: (function() {
      function _Class(_arg) {
        this.continuation = _arg;
        this.count = 1;
        this.ret = null;
      }

      _Class.prototype._fulfill = function() {
        if (!--this.count) {
          return this.continuation(this.ret);
        }
      };

      _Class.prototype.defer = function(defer_params) {
        var _this = this;
        ++this.count;
        return function() {
          var inner_params, _ref;
          inner_params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          if (defer_params != null) {
            if ((_ref = defer_params.assign_fn) != null) {
              _ref.apply(null, inner_params);
            }
          }
          return _this._fulfill();
        };
      };

      return _Class;

    })(),
    findDeferral: function() {
      return null;
    },
    trampoline: function(_fn) {
      return _fn();
    }
  };
  __iced_k = __iced_k_noop = function() {};

  fs = require('fs');

  path = require('path');

  crypto = require('crypto');

  brew = (function() {
    function brew(o) {
      var p, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      this._log = __bind(this._log, this);

      /*
      o (dict argument): 
        includes:   a sorted list of files and/or dirs to include
        excludes:   (optional) any exceptions (files and/or dirs) to the includes
        match:      (optional) a regular expression any file must match; say if you want to limit to extensions
        compile:    (optional) fn to call on each file's contents; takes (filename, str, cb) as arguments; if missing, just returns text
        join:       (optional) fn takes all the (sorted) compiled strings and joins them together for final output
        compress:   (optional) fn that takes final output str and combines together into a new compressed string
        onChange:   (optional) a callback when anything changes in the brew. takes (passes version_hash, txt) as argument
        onReady:    (optional) a callback for when the first compilation pass is done and the brew is ready
        logger:     (optional) a function that handles lines of logs
        loop_delay: (optional) time in ms between checking for filesystem changes
        change_triggers: (optional) an array of pairs of regexps, where the first item is a regexp matching trigger files, and the second matches target files
          if a file matching the first regexp changes (the source or the compilation), it will trigger
            a recompile of any known file matching the righthand regexp, even if that file hasn't changed.
            for example: [/styl\/colors.styl^\/, \/styl\/.*.styl^/] recompiles everything in the styl directory if colors.styl changes
      */
      this._includes = (function() {
        var _i, _len, _ref, _results;
        _ref = o.includes || [];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          _results.push(path.resolve(p));
        }
        return _results;
      })();
      this._excludes = (function() {
        var _i, _len, _ref, _results;
        _ref = o.excludes || [];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          _results.push(path.resolve(p));
        }
        return _results;
      })();
      this._match = o.match || /.*/;
      this._compile = o.compile || function(p, str, cb) {
        return cb(null, str);
      };
      this._join = o.join || function(strs, cb) {
        return cb(null, strs.join("\n"));
      };
      this._compress = o.compress || null;
      this._onChange = o.onChange || function(version_hash, txt, compressed_txt) {};
      this._onReady = o.onReady || function(version_hash, txt, compressed_txt) {};
      this._logger = o.logger || null;
      this._loop_delay = o.loop_delay || 500;
      this._change_triggers = o.change_triggers || [];
      this._versionHash = null;
      this._txt = null;
      this._compressed_txt = null;
      this._files = {};
      this._ready_yet = false;
      this._alive = true;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/brew.coffee",
          funcname: "brew"
        });
        _this._fullPass(__iced_deferrals.defer({
          lineno: 41
        }));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/brew.coffee",
            funcname: "brew"
          });
          _this._flipToNewContent(__iced_deferrals.defer({
            lineno: 42
          }));
          __iced_deferrals._fulfill();
        })(function() {
          _this._ready_yet = true;
          if (o.onReady != null) {
            o.onReady(_this.getVersionHash(), _this.getCompiledText(), _this.getCompressedText());
          }
          return _this._monitorLoop();
        });
      });
    }

    brew.prototype.isReady = function() {
      return (this._versionHash != null) && (this._txt != null);
    };

    brew.prototype.getVersionHash = function() {
      if (!this.isReady()) {
        throw new Error("getVersionHash() called before onReady(); wait for your brew to brew or check isReady()!");
      }
      return this._versionHash;
    };

    brew.prototype.getCompiledText = function() {
      if (!this.isReady()) {
        throw new Error("getCompiledText() called before onReady(); wait for your brew to brew or check isReady()!");
      }
      return this._txt;
    };

    brew.prototype.getCompressedText = function() {
      if (!((this._versionHash != null) && (this._compressed_txt != null))) {
        throw new Error("getCompressedText() called before onReady(); wait for your brew to brew!");
      }
      if (this._compress == null) {
        this._log("requested compressed text, but not compress fn provided; returning regular text");
        return this._txt;
      }
      return this._compressed_txt;
    };

    brew.prototype.kill = function() {
      return this._alive = false;
    };

    brew.prototype._log = function(str) {
      if (this._logger != null) {
        return this._logger(str);
      }
    };

    brew.prototype._fullPass = function(cb) {
      var any_changes, changes, i, p, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      any_changes = false;
      (function(__iced_k) {
        var _i, _len, _ref, _results, _while;
        _ref = _this._includes;
        _len = _ref.length;
        i = 0;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              ++i;
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(i < _len)) {
            return _break();
          } else {
            p = _ref[i];
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/brew.coffee",
                funcname: "brew._fullPass"
              });
              _this._recurse(p, i, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return changes = arguments[0];
                  };
                })(),
                lineno: 81
              }));
              __iced_deferrals._fulfill();
            })(function() {
              return _next(any_changes = any_changes || changes);
            });
          }
        };
        _while(__iced_k);
      })(function() {
        return cb(any_changes);
      });
    };

    brew.prototype._checkKnownFiles = function(cb) {
      var any_changes, changes, err, file, p, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      any_changes = false;
      (function(__iced_k) {
        var _i, _k, _keys, _ref, _results, _while;
        _ref = _this._files;
        _keys = (function() {
          var _results1;
          _results1 = [];
          for (_k in _ref) {
            _results1.push(_k);
          }
          return _results1;
        })();
        _i = 0;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              ++_i;
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(_i < _keys.length)) {
            return _break();
          } else {
            p = _keys[_i];
            file = _ref[p];
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/brew.coffee",
                funcname: "brew._checkKnownFiles"
              });
              _this._possiblyReload(p, file, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    err = arguments[0];
                    return changes = arguments[1];
                  };
                })(),
                lineno: 88
              }));
              __iced_deferrals._fulfill();
            })(function() {
              if (err) {
                delete _this._files[p];
              }
              return _next(any_changes = any_changes || changes);
            });
          }
        };
        _while(__iced_k);
      })(function() {
        return cb(any_changes);
      });
    };

    brew.prototype._monitorLoop = function() {
      var any_final_changes, changes_1, changes_2, d, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      d = Date.now();
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/brew.coffee",
          funcname: "brew._monitorLoop"
        });
        _this._checkKnownFiles(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return changes_1 = arguments[0];
            };
          })(),
          lineno: 99
        }));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/brew.coffee",
            funcname: "brew._monitorLoop"
          });
          _this._fullPass(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return changes_2 = arguments[0];
              };
            })(),
            lineno: 102
          }));
          __iced_deferrals._fulfill();
        })(function() {
          (function(__iced_k) {
            if (changes_1 || changes_2) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/brew.coffee",
                  funcname: "brew._monitorLoop"
                });
                _this._flipToNewContent(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return any_final_changes = arguments[0];
                    };
                  })(),
                  lineno: 106
                }));
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            if (any_final_changes) {
              _this._log("[" + (Date.now() - d) + "ms] flipToNewContent: (" + _this._versionHash + ")");
            }
            if (_this._alive) {
              return setTimeout((function() {
                return _this._monitorLoop();
              }), _this._loop_delay);
            }
          });
        });
      });
    };

    brew.prototype._flipToNewContent = function(cb) {
      var any_changes, cres, err, f, fp, paths, res, txts, ___iced_passed_deferral, __iced_deferrals, __iced_k, _i, _len,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);

      /*
      puts together all the compilations
      and generates a new version number
      */
      paths = (function() {
        var _ref, _results;
        _ref = this._files;
        _results = [];
        for (fp in _ref) {
          f = _ref[fp];
          if (f.isOk()) {
            _results.push(fp);
          }
        }
        return _results;
      }).call(this);
      paths.sort(function(a, b) {
        return _this._files[a].getPriority() - _this._files[b].getPriority();
      });
      txts = [];
      for (_i = 0, _len = paths.length; _i < _len; _i++) {
        fp = paths[_i];
        txts.push(this._files[fp].getCompiledText());
      }
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/brew.coffee",
          funcname: "brew._flipToNewContent"
        });
        _this._join(txts, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return res = arguments[1];
            };
          })(),
          lineno: 125
        }));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          if (res !== _this._txt) {
            (function(__iced_k) {
              if (_this._compress != null) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "src/brew.coffee",
                    funcname: "brew._flipToNewContent"
                  });
                  _this._compress(res, __iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        err = arguments[0];
                        return cres = arguments[1];
                      };
                    })(),
                    lineno: 128
                  }));
                  __iced_deferrals._fulfill();
                })(function() {
                  return __iced_k(_this._compressed_txt = cres);
                });
              } else {
                return __iced_k();
              }
            })(function() {
              _this._txt = res;
              _this._versionHash = crypto.createHash('md5').update("" + _this._txt).digest('hex').slice(0, 8);
              if (_this._ready_yet) {
                _this._onChange(_this._versionHash, _this._txt, _this.getCompressedText());
              }
              return __iced_k(any_changes = true);
            });
          } else {
            return __iced_k(any_changes = false);
          }
        })(function() {
          return cb(any_changes);
        });
      });
    };

    brew.prototype._recurse = function(p, priority, cb) {
      var any_changes, changes, err, f, files, fp, stat, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);

      /*
      p:  a file or directory
      cb: true if anything has changed
      */
      any_changes = false;
      (function(__iced_k) {
        if (!(__indexOf.call(_this._excludes, p) >= 0)) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/brew.coffee",
              funcname: "brew._recurse"
            });
            fs.stat(p, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  err = arguments[0];
                  return stat = arguments[1];
                };
              })(),
              lineno: 146
            }));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              if (!err) {
                (function(__iced_k) {
                  if (stat.isDirectory()) {
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "src/brew.coffee",
                        funcname: "brew._recurse"
                      });
                      fs.readdir(p, __iced_deferrals.defer({
                        assign_fn: (function() {
                          return function() {
                            err = arguments[0];
                            return files = arguments[1];
                          };
                        })(),
                        lineno: 149
                      }));
                      __iced_deferrals._fulfill();
                    })(function() {
                      (function(__iced_k) {
                        if (!err) {
                          (function(__iced_k) {
                            var _i, _len, _ref, _results, _while;
                            _ref = files;
                            _len = _ref.length;
                            _i = 0;
                            _results = [];
                            _while = function(__iced_k) {
                              var _break, _continue, _next;
                              _break = function() {
                                return __iced_k(_results);
                              };
                              _continue = function() {
                                return iced.trampoline(function() {
                                  ++_i;
                                  return _while(__iced_k);
                                });
                              };
                              _next = function(__iced_next_arg) {
                                _results.push(__iced_next_arg);
                                return _continue();
                              };
                              if (!(_i < _len)) {
                                return _break();
                              } else {
                                f = _ref[_i];
                                fp = path.join(p, f);
                                (function(__iced_k) {
                                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                                    parent: ___iced_passed_deferral,
                                    filename: "src/brew.coffee",
                                    funcname: "brew._recurse"
                                  });
                                  _this._recurse(fp, priority, __iced_deferrals.defer({
                                    assign_fn: (function() {
                                      return function() {
                                        return changes = arguments[0];
                                      };
                                    })(),
                                    lineno: 153
                                  }));
                                  __iced_deferrals._fulfill();
                                })(function() {
                                  return _next(any_changes = any_changes || changes);
                                });
                              }
                            };
                            _while(__iced_k);
                          })(__iced_k);
                        } else {
                          return __iced_k();
                        }
                      })(__iced_k);
                    });
                  } else {
                    (function(__iced_k) {
                      if (stat.isFile()) {
                        (function(__iced_k) {
                          if (path.basename(p).match(_this._match)) {
                            (function(__iced_k) {
                              __iced_deferrals = new iced.Deferrals(__iced_k, {
                                parent: ___iced_passed_deferral,
                                filename: "src/brew.coffee",
                                funcname: "brew._recurse"
                              });
                              _this._recurseHandleFile(p, priority, __iced_deferrals.defer({
                                assign_fn: (function() {
                                  return function() {
                                    return changes = arguments[0];
                                  };
                                })(),
                                lineno: 157
                              }));
                              __iced_deferrals._fulfill();
                            })(function() {
                              return __iced_k(any_changes = any_changes || changes);
                            });
                          } else {
                            return __iced_k();
                          }
                        })(__iced_k);
                      } else {
                        return __iced_k();
                      }
                    })(__iced_k);
                  }
                })(__iced_k);
              } else {
                return __iced_k(_this._files[p] != null ? (delete _this._files[p], _this._log("removing " + p + " from files; it went missing"), any_changes = true) : void 0);
              }
            })(__iced_k);
          });
        } else {
          return __iced_k();
        }
      })(function() {
        return cb(any_changes);
      });
    };

    brew.prototype._recurseHandleFile = function(p, priority, cb) {
      var did_reload, err, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      did_reload = false;
      (function(__iced_k) {
        if (_this._files[p] == null) {
          _this._files[p] = new file(p, priority, _this._log);
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/brew.coffee",
              funcname: "brew._recurseHandleFile"
            });
            _this._possiblyReload(p, _this._files[p], __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  err = arguments[0];
                  return did_reload = arguments[1];
                };
              })(),
              lineno: 171
            }));
            __iced_deferrals._fulfill();
          })(__iced_k);
        } else {
          return __iced_k(_this._files[p].setPriority(Math.min(priority, _this._files[p].getPriority())));
        }
      })(function() {
        return cb(did_reload);
      });
    };

    brew.prototype._possiblyReload = function(p, f, cb) {
      var ct, did_reload, err, f2, f2_reloaded, p2, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/brew.coffee",
          funcname: "brew._possiblyReload"
        });
        f.possiblyReload(_this._compile, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return did_reload = arguments[1];
            };
          })(),
          lineno: 177
        }));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          if (did_reload) {
            (function(__iced_k) {
              var _i, _len, _ref, _results, _while;
              _ref = _this._change_triggers;
              _len = _ref.length;
              _i = 0;
              _results = [];
              _while = function(__iced_k) {
                var _break, _continue, _next;
                _break = function() {
                  return __iced_k(_results);
                };
                _continue = function() {
                  return iced.trampoline(function() {
                    ++_i;
                    return _while(__iced_k);
                  });
                };
                _next = function(__iced_next_arg) {
                  _results.push(__iced_next_arg);
                  return _continue();
                };
                if (!(_i < _len)) {
                  return _break();
                } else {
                  ct = _ref[_i];
                  (function(__iced_k) {
                    if (p.match(ct[0])) {
                      (function(__iced_k) {
                        if (f.isOk()) {
                          (function(__iced_k) {
                            var _j, _k, _keys, _ref1, _results1, _while;
                            _ref1 = _this._files;
                            _keys = (function() {
                              var _results2;
                              _results2 = [];
                              for (_k in _ref1) {
                                _results2.push(_k);
                              }
                              return _results2;
                            })();
                            _j = 0;
                            _results1 = [];
                            _while = function(__iced_k) {
                              var _break, _continue, _next;
                              _break = function() {
                                return __iced_k(_results1);
                              };
                              _continue = function() {
                                return iced.trampoline(function() {
                                  ++_j;
                                  return _while(__iced_k);
                                });
                              };
                              _next = function(__iced_next_arg) {
                                _results1.push(__iced_next_arg);
                                return _continue();
                              };
                              if (!(_j < _keys.length)) {
                                return _break();
                              } else {
                                p2 = _keys[_j];
                                f2 = _ref1[p2];
                                if (f2 !== f) {
                                  (function(__iced_k) {
                                    if (p2.match(ct[1])) {
                                      (function(__iced_k) {
                                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                                          parent: ___iced_passed_deferral,
                                          filename: "src/brew.coffee",
                                          funcname: "brew._possiblyReload"
                                        });
                                        f2.reload(_this._compile, true, __iced_deferrals.defer({
                                          assign_fn: (function() {
                                            return function() {
                                              return f2_reloaded = arguments[0];
                                            };
                                          })(),
                                          lineno: 185
                                        }));
                                        __iced_deferrals._fulfill();
                                      })(function() {
                                        return __iced_k(f2_reloaded ? _this._log("" + p + " triggered a recompile of " + p2) : void 0);
                                      });
                                    } else {
                                      return __iced_k();
                                    }
                                  })(_next);
                                } else {
                                  return _continue();
                                }
                              }
                            };
                            _while(__iced_k);
                          })(__iced_k);
                        } else {
                          return __iced_k(_this._log("" + p + " isn't ok, so change trigger ignored"));
                        }
                      })(__iced_k);
                    } else {
                      return __iced_k();
                    }
                  })(_next);
                }
              };
              _while(__iced_k);
            })(__iced_k);
          } else {
            return __iced_k();
          }
        })(function() {
          return cb(err, did_reload);
        });
      });
    };

    return brew;

  })();

  file = (function() {
    function file(p, priority, log_fn) {

      /*
        p = path
        pri = 0, 1, etc. (0 is lowest)
      */
      this._log = log_fn || function() {};
      this._path = p;
      this._priority = priority;
      this._src_txt = null;
      this._compiled_txt = null;
      this._err = null;
      this._lastChecked = null;
    }

    file.prototype.reload = function(compile_fn, force, cb) {
      var compiled_changed, data, err, now, old_compiled_txt, old_src_txt, reloaded, src_changed, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);

      /*
        if force is set to true, then the 
        file will be recompiled even if the src
        is unchanged; this makes sense if we know the
        file depends on something else which has changed,
        say an import in a .styl file
      */
      now = Date.now();
      old_src_txt = this._src_txt;
      old_compiled_txt = this._compiled_txt;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/brew.coffee",
          funcname: "file.reload"
        });
        fs.readFile(_this._path, "utf8", __iced_deferrals.defer({
          assign_fn: (function(__slot_1) {
            return function() {
              __slot_1._err = arguments[0];
              return data = arguments[1];
            };
          })(_this),
          lineno: 220
        }));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          if (!_this._err) {
            (function(__iced_k) {
              if ((data !== _this._src_txt) || force) {
                _this._src_txt = data;
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "src/brew.coffee",
                    funcname: "file.reload"
                  });
                  compile_fn(_this._path, _this._src_txt, __iced_deferrals.defer({
                    assign_fn: (function(__slot_1) {
                      return function() {
                        err = arguments[0];
                        return __slot_1._compiled_txt = arguments[1];
                      };
                    })(_this),
                    lineno: 224
                  }));
                  __iced_deferrals._fulfill();
                })(__iced_k);
              } else {
                return __iced_k();
              }
            })(function() {
              src_changed = _this._src_txt !== old_src_txt;
              compiled_changed = _this._compiled_txt !== old_compiled_txt;
              reloaded = src_changed || compiled_changed;
              if (reloaded) {
                _this._log("[" + (Date.now() - now) + "ms] " + _this._path + " changed; src changed: " + src_changed + " | compiled changed: " + compiled_changed);
              }
              return __iced_k(_this._lastChecked = now);
            });
          } else {
            _this._log("Error reading file: " + _this._path + " - counting as reload");
            return __iced_k(reloaded = true);
          }
        })(function() {
          return cb(reloaded);
        });
      });
    };

    file.prototype.possiblyReload = function(compile_fn, cb) {
      var changed, reloaded, stat, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      reloaded = false;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/brew.coffee",
          funcname: "file.possiblyReload"
        });
        fs.stat(_this._path, __iced_deferrals.defer({
          assign_fn: (function(__slot_1) {
            return function() {
              __slot_1._err = arguments[0];
              return stat = arguments[1];
            };
          })(_this),
          lineno: 238
        }));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          if (!_this._err) {
            changed = Math.max(stat.mtime.getTime(), stat.ctime.getTime());
            (function(__iced_k) {
              if (changed >= _this._lastChecked - 1000) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "src/brew.coffee",
                    funcname: "file.possiblyReload"
                  });
                  _this.reload(compile_fn, false, __iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return reloaded = arguments[0];
                      };
                    })(),
                    lineno: 242
                  }));
                  __iced_deferrals._fulfill();
                })(__iced_k);
              } else {
                return __iced_k();
              }
            })(__iced_k);
          } else {
            return __iced_k();
          }
        })(function() {
          if (_this._err) {
            reloaded = true;
          }
          return cb(_this._err, reloaded);
        });
      });
    };

    file.prototype.isOk = function() {
      return !this._err;
    };

    file.prototype.getCompiledText = function() {
      return this._compiled_txt;
    };

    file.prototype.getSrc = function() {
      return this._src;
    };

    file.prototype.getPriority = function() {
      return this._priority;
    };

    file.prototype.setPriority = function(pri) {
      return this._priority = pri;
    };

    file.prototype.getPath = function() {
      return this._path;
    };

    return file;

  })();

  exports.brew = brew;

}).call(this);
